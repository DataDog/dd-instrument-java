/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2025-Present Datadog, Inc.
 */

package datadog.instrument.glue;

import java.lang.reflect.Method;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

/** Generates instrumentation glue for projects that apply the {@code instrument-glue} plugin. */
public final class GlueGenerator {

  private GlueGenerator() {}

  /**
   * Entry-point for generating instrumentation glue into resource files or Java source code.
   *
   * @param args the command-line arguments
   */
  public static void main(String[] args) throws ReflectiveOperationException {
    if (args.length < 3) {
      throw new IllegalArgumentException("Expected: resource-path java-path glue-name...");
    }
    Path resourcePath = Paths.get(args[0]);
    Path javaPath = Paths.get(args[1]);
    for (int i = 2; i < args.length; i++) {
      Class<?> generatorClass = Class.forName("datadog.instrument.glue." + args[i] + "Generator");
      Method generateGlue = generatorClass.getMethod("generateGlue", Path.class, Path.class);
      generateGlue.invoke(null, resourcePath, javaPath);
    }
  }

  /**
   * Writes the source header of a class to hold the string representation of glue bytecode.
   *
   * @param lines the list collecting the source code
   * @param className the name of the generated class
   */
  public static void classHeader(List<String> lines, String className) {
    lines.add("package datadog.instrument.glue;");
    lines.add("");
    lines.add("/** Generated by " + className + "Generator - DO NOT EDIT! */");
    lines.add("public interface " + className + " {");
  }

  /**
   * Packs the given glue bytecode as a string literal and writes it out in source code form.
   *
   * <p>The bytecode must be padded to have even length, as this simplifies the encoding/decoding.
   *
   * @param lines the list collecting the source code
   * @param bytecode the bytecode to pack
   */
  public static void packBytecode(List<String> lines, byte[] bytecode) {
    if ((bytecode.length & 0x01) == 1) {
      throw new IllegalStateException("Bytecode length is not even; requires padding");
    }
    StringBuilder buf = new StringBuilder("      \"");
    // encode bytes using lenient form of UTF_16BE: no BOM, allow unpaired surrogates
    // this is so we can unpack it later without requiring any special/complex code
    for (int i = 0; i < bytecode.length; i += 2) {
      if (buf.length() > 120) {
        lines.add(buf + "\"");
        buf.setLength(0);
        buf.append("          + \"");
      }
      // pack 2 bytes into one char using big-endian ordering
      char c = (char) ((bytecode[i] << 8) | (0x00FF & bytecode[i + 1]));
      if (c <= 0x00FF) {
        buf.append(String.format("\\%03o", (int) c));
      } else {
        buf.append(String.format("\\u%04x", (int) c));
      }
    }
    lines.add(buf + "\";");
  }
}
