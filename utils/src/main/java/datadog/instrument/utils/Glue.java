/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2025-Present Datadog, Inc.
 */

package datadog.instrument.utils;

import static java.nio.charset.StandardCharsets.UTF_16BE;

import java.util.List;

/** Methods for packing glue bytecode into strings that can be stored in the constant pool. */
public final class Glue {

  private Glue() {}

  /**
   * Writes the source header of a class to hold the string representation of glue bytecode.
   *
   * @param lines the list collecting the source code
   * @param className the name of the generated class
   */
  public static void classHeader(List<String> lines, String className) {
    lines.add("package datadog.instrument.glue;");
    lines.add("");
    lines.add("/** Generated by " + className + "Generator - DO NOT EDIT! */");
    lines.add("public interface " + className + " {");
  }

  /**
   * Packs the given glue bytecode as a string literal and writes it out in source code form.
   *
   * <p>The bytecode must be padded to have even length, as this simplifies the encoding/decoding.
   *
   * @param lines the list collecting the source code
   * @param bytecode the bytecode to pack
   */
  public static void packBytecode(List<String> lines, byte[] bytecode) {
    if ((bytecode.length & 0x01) == 1) {
      throw new IllegalStateException("Bytecode length is not even; requires padding");
    }
    StringBuilder buf = new StringBuilder("      \"");
    // encode bytes using lenient form of UTF_16BE: no BOM, allow unpaired surrogates
    // this is so we can unpack it later without requiring any special/complex code
    for (int i = 0; i < bytecode.length; i += 2) {
      if (buf.length() > 120) {
        lines.add(buf + "\"");
        buf.setLength(0);
        buf.append("          + \"");
      }
      // pack 2 bytes into one char using big-endian ordering
      char c = (char) ((bytecode[i] << 8) | (0x00FF & bytecode[i + 1]));
      if (c <= 0x00FF) {
        buf.append(String.format("\\%03o", (int) c));
      } else {
        buf.append(String.format("\\u%04x", (int) c));
      }
    }
    lines.add(buf + "\";");
  }

  /**
   * Unpacks a string literal produced by {@link #packBytecode} back into the original bytecode.
   *
   * @param bytecode the packed bytecode
   * @return the unpacked bytecode
   */
  public static byte[] unpackBytecode(String bytecode) {
    return bytecode.getBytes(UTF_16BE);
  }
}
