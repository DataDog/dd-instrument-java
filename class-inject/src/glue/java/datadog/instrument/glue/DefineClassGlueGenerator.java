package datadog.instrument.glue;

import static org.objectweb.asm.Opcodes.*;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.function.BiFunction;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;

/**
 * Generates glue bytecode for a {@link BiFunction} around {@code Unsafe.defineClass} that takes a
 * byte-array and class-loader (or protection domain) and returns a class. The generated bytecode is
 * encoded as a UTF-16 (BE) string and written as a constant inside a Java class at build-time.
 *
 * <p>At runtime the bytecode is decoded from the string and defined as a hidden/anonymous class
 * using instrumentation. The resulting function provides access to {@code Unsafe.defineClass}
 * without unsafe reflection.
 *
 * <p>Two versions of bytecode are generated: one for Java 8 that uses {@code sun.misc.Unsafe} and
 * another for Java 9+ that uses {@code jdk.internal.misc.Unsafe}.
 */
final class DefineClassGlueGenerator {
  // our glue must be located inside the java.lang namespace for accessibility reasons
  private static final String DATADOG_GLUE_CLASS = "java/lang/$Datadog$DefineClass$Glue$";

  private static final String OBJECT_CLASS = "java/lang/Object";
  private static final String CLASS_CLASS = "java/lang/Class";
  private static final String STRING_CLASS = "java/lang/String";

  private static final String BYTE_ARRAY = "[B";

  private static final String CLASSLOADER_CLASS = "java/lang/ClassLoader";
  private static final String PROTECTIONDOMAIN_CLASS = "java/security/ProtectionDomain";
  private static final String BIFUNCTION_CLASS = "java/util/function/BiFunction";

  // to keep the bytecode small we only implement the raw API
  private static final String BIFUNCTION_APPLY_DESCRIPTOR =
      "(L" + OBJECT_CLASS + ";L" + OBJECT_CLASS + ";)L" + OBJECT_CLASS + ";";

  private static final String UNSAFE_DEFINECLASS_DESCRIPTOR =
      "(L"
          + STRING_CLASS
          + ";"
          + BYTE_ARRAY
          + "IIL"
          + CLASSLOADER_CLASS
          + ";L"
          + PROTECTIONDOMAIN_CLASS
          + ";)L"
          + CLASS_CLASS
          + ";";

  private static byte[] generateBytecode(String unsafeNamespace) {
    final String unsafeClass = unsafeNamespace + "/Unsafe";
    final String unsafeDescriptor = "L" + unsafeClass + ";";

    ClassWriter cw = new ClassWriter(0);

    cw.visit(
        V1_8,
        ACC_PUBLIC | ACC_FINAL,
        DATADOG_GLUE_CLASS,
        null,
        OBJECT_CLASS,
        new String[] {BIFUNCTION_CLASS});

    cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, "UNSAFE", unsafeDescriptor, null, null)
        .visitEnd();

    MethodVisitor mv;

    // cache the Unsafe instance locally as a static constant
    mv = cw.visitMethod(ACC_STATIC, "<clinit>", "()V", null, null);
    mv.visitCode();
    mv.visitMethodInsn(INVOKESTATIC, unsafeClass, "getUnsafe", "()" + unsafeDescriptor, false);
    mv.visitFieldInsn(PUTSTATIC, DATADOG_GLUE_CLASS, "UNSAFE", unsafeDescriptor);
    mv.visitInsn(RETURN);
    mv.visitMaxs(1, 0);
    mv.visitEnd();

    mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
    mv.visitCode();
    mv.visitVarInsn(ALOAD, 0);
    mv.visitMethodInsn(INVOKESPECIAL, OBJECT_CLASS, "<init>", "()V", false);
    mv.visitInsn(RETURN);
    mv.visitMaxs(1, 1);
    mv.visitEnd();

    mv = cw.visitMethod(ACC_PUBLIC, "apply", BIFUNCTION_APPLY_DESCRIPTOR, null, null);

    Label notProtectionDomain = new Label();
    Label invokeDefineClass = new Label();

    mv.visitCode();

    // NOTE: the following bytecode makes use of DUP and SWAP to limit loads

    // prepare most of the arguments for Unsafe.defineClass
    mv.visitFieldInsn(GETSTATIC, DATADOG_GLUE_CLASS, "UNSAFE", unsafeDescriptor);
    mv.visitInsn(ACONST_NULL);
    mv.visitVarInsn(ALOAD, 1);
    mv.visitTypeInsn(CHECKCAST, BYTE_ARRAY);
    mv.visitInsn(DUP);
    mv.visitInsn(ARRAYLENGTH);
    mv.visitInsn(ICONST_0);
    mv.visitInsn(SWAP);
    mv.visitVarInsn(ALOAD, 2);
    mv.visitInsn(DUP);
    mv.visitTypeInsn(INSTANCEOF, PROTECTIONDOMAIN_CLASS);
    mv.visitJumpInsn(IFEQ, notProtectionDomain);

    // second argument is a protection-domain, extract class-loader from it
    mv.visitTypeInsn(CHECKCAST, PROTECTIONDOMAIN_CLASS);
    mv.visitInsn(DUP);
    mv.visitMethodInsn(
        INVOKEVIRTUAL,
        PROTECTIONDOMAIN_CLASS,
        "getClassLoader",
        "()L" + CLASSLOADER_CLASS + ";",
        false);
    mv.visitInsn(SWAP);
    mv.visitJumpInsn(GOTO, invokeDefineClass);

    // second argument is a class-loader, use a null protection-domain
    mv.visitLabel(notProtectionDomain);
    mv.visitFrame(
        F_FULL,
        3,
        new Object[] {DATADOG_GLUE_CLASS, OBJECT_CLASS, OBJECT_CLASS},
        6,
        new Object[] {unsafeClass, NULL, BYTE_ARRAY, INTEGER, INTEGER, OBJECT_CLASS});

    mv.visitTypeInsn(CHECKCAST, CLASSLOADER_CLASS);
    mv.visitInsn(ACONST_NULL);

    // finally invoke Unsafe.defineClass and return the defined class
    mv.visitLabel(invokeDefineClass);
    mv.visitFrame(
        F_FULL,
        3,
        new Object[] {DATADOG_GLUE_CLASS, OBJECT_CLASS, OBJECT_CLASS},
        7,
        new Object[] {
          unsafeClass, NULL, BYTE_ARRAY, INTEGER, INTEGER, CLASSLOADER_CLASS, PROTECTIONDOMAIN_CLASS
        });

    mv.visitMethodInsn(
        INVOKEVIRTUAL, unsafeClass, "defineClass", UNSAFE_DEFINECLASS_DESCRIPTOR, false);
    mv.visitInsn(ARETURN);

    // pad bytecode so the final length is even
    if ((unsafeNamespace.length() & 0x01) == 1) {
      mv.visitInsn(NOP);
    }

    mv.visitMaxs(7, 3);
    cw.visitEnd();

    return cw.toByteArray();
  }

  private static void packBytecode(List<String> lines, String unsafeNamespace) {
    byte[] bytecode = generateBytecode(unsafeNamespace);
    if ((bytecode.length & 0x01) == 1) {
      throw new IllegalStateException("Generated bytecode needs padding to make length even");
    }
    StringBuilder buf = new StringBuilder("      \"");
    for (int i = 0; i < bytecode.length; i += 2) {
      if (buf.length() > 120) {
        lines.add(buf + "\"");
        buf.setLength(0);
        buf.append("          + \"");
      }
      // pack 2 bytes into one char (UTF_16BE)
      char c = (char) ((bytecode[i] << 8) | (0x00FF & bytecode[i + 1]));
      if (c <= 0x00FF) {
        buf.append(String.format("\\%03o", (int) c));
      } else {
        buf.append(String.format("\\u%04x", (int) c));
      }
    }
    lines.add(buf + "\";");
  }

  public static void main(String[] args) throws IOException {
    if (args.length < 3) {
      throw new IllegalArgumentException("Expected: java-file pkg clz");
    }
    Path javaFile = Paths.get(args[0]).toAbsolutePath().normalize();
    List<String> lines = new ArrayList<>();
    lines.add("package " + args[1] + ";");
    lines.add("");
    lines.add("// Generated by " + DefineClassGlueGenerator.class.getName() + " - DO NOT EDIT!");
    lines.add("final class " + args[2] + " {");
    lines.add("  static final String ID = \"" + DATADOG_GLUE_CLASS.replace('/', '.') + "\";");
    lines.add("  static final String V8 =");
    packBytecode(lines, "sun/misc");
    lines.add("  static final String V9 =");
    packBytecode(lines, "jdk/internal/misc");
    lines.add("}");
    Files.write(javaFile, lines, StandardCharsets.UTF_8);
  }
}
