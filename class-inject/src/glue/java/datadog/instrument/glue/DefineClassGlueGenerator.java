package datadog.instrument.glue;

import static datadog.instrument.utils.Glue.classHeader;
import static datadog.instrument.utils.Glue.packBytecode;
import static org.objectweb.asm.Opcodes.*;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.List;
import java.util.function.BiFunction;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;

/**
 * Generates glue bytecode for a {@link BiFunction} around {@code Unsafe.defineClass} that takes a
 * byte-array and class-loader (or protection domain) and returns a class. The generated bytecode is
 * encoded as a UTF-16BE string and written as a constant inside a Java class at build-time.
 *
 * <p>At runtime the bytecode is decoded from the string and defined as a hidden/anonymous class
 * using instrumentation. The resulting function provides access to {@code Unsafe.defineClass}
 * without unsafe reflection.
 *
 * <p>Two versions of bytecode are generated: one for Java 8 that uses {@code sun.misc.Unsafe} and
 * another for Java 9+ that uses {@code jdk.internal.misc.Unsafe}.
 */
final class DefineClassGlueGenerator {
  // our glue must be located inside the java.lang namespace for accessibility reasons
  private static final String INJECTED_GLUE_CLASS = "java/lang/$Datadog$DefineClass$Glue$";

  private static final String OBJECT_CLASS = "java/lang/Object";
  private static final String CLASS_CLASS = "java/lang/Class";
  private static final String STRING_CLASS = "java/lang/String";

  private static final String BYTE_ARRAY = "[B";

  private static final String CLASSLOADER_CLASS = "java/lang/ClassLoader";
  private static final String PROTECTIONDOMAIN_CLASS = "java/security/ProtectionDomain";
  private static final String BIFUNCTION_CLASS = "java/util/function/BiFunction";

  // to keep the bytecode small we only implement the raw API
  private static final String BIFUNCTION_APPLY_DESCRIPTOR =
      "(L" + OBJECT_CLASS + ";L" + OBJECT_CLASS + ";)L" + OBJECT_CLASS + ";";

  private static final String UNSAFE_DEFINECLASS_DESCRIPTOR =
      "(L"
          + STRING_CLASS
          + ";"
          + BYTE_ARRAY
          + "IIL"
          + CLASSLOADER_CLASS
          + ";L"
          + PROTECTIONDOMAIN_CLASS
          + ";)L"
          + CLASS_CLASS
          + ";";

  private static byte[] generateBytecode(String unsafeNamespace) {
    final String unsafeClass = unsafeNamespace + "/Unsafe";
    final String unsafeDescriptor = "L" + unsafeClass + ";";

    ClassWriter cw = new ClassWriter(0);

    cw.visit(
        V1_8,
        ACC_PUBLIC | ACC_FINAL,
        INJECTED_GLUE_CLASS,
        null,
        OBJECT_CLASS,
        new String[] {BIFUNCTION_CLASS});

    cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, "UNSAFE", unsafeDescriptor, null, null)
        .visitEnd();

    MethodVisitor mv;

    // cache the Unsafe instance locally as a static constant
    mv = cw.visitMethod(ACC_STATIC, "<clinit>", "()V", null, null);
    mv.visitCode();
    mv.visitMethodInsn(INVOKESTATIC, unsafeClass, "getUnsafe", "()" + unsafeDescriptor, false);
    mv.visitFieldInsn(PUTSTATIC, INJECTED_GLUE_CLASS, "UNSAFE", unsafeDescriptor);
    mv.visitInsn(RETURN);
    mv.visitMaxs(1, 0);
    mv.visitEnd();

    mv = cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
    mv.visitCode();
    mv.visitVarInsn(ALOAD, 0);
    mv.visitMethodInsn(INVOKESPECIAL, OBJECT_CLASS, "<init>", "()V", false);
    mv.visitInsn(RETURN);
    mv.visitMaxs(1, 1);
    mv.visitEnd();

    mv = cw.visitMethod(ACC_PUBLIC, "apply", BIFUNCTION_APPLY_DESCRIPTOR, null, null);

    Label notProtectionDomain = new Label();
    Label invokeDefineClass = new Label();

    mv.visitCode();

    // NOTE: the following bytecode makes use of DUP and SWAP to limit loads

    // prepare most of the arguments for Unsafe.defineClass
    mv.visitFieldInsn(GETSTATIC, INJECTED_GLUE_CLASS, "UNSAFE", unsafeDescriptor);
    mv.visitInsn(ACONST_NULL);
    mv.visitVarInsn(ALOAD, 1);
    mv.visitTypeInsn(CHECKCAST, BYTE_ARRAY);
    mv.visitInsn(DUP);
    mv.visitInsn(ARRAYLENGTH);
    mv.visitInsn(ICONST_0);
    mv.visitInsn(SWAP);
    mv.visitVarInsn(ALOAD, 2);
    mv.visitInsn(DUP);
    mv.visitTypeInsn(INSTANCEOF, PROTECTIONDOMAIN_CLASS);
    mv.visitJumpInsn(IFEQ, notProtectionDomain);

    // second argument is a protection-domain, extract class-loader from it
    mv.visitTypeInsn(CHECKCAST, PROTECTIONDOMAIN_CLASS);
    mv.visitInsn(DUP);
    mv.visitMethodInsn(
        INVOKEVIRTUAL,
        PROTECTIONDOMAIN_CLASS,
        "getClassLoader",
        "()L" + CLASSLOADER_CLASS + ";",
        false);
    mv.visitInsn(SWAP);
    mv.visitJumpInsn(GOTO, invokeDefineClass);

    // second argument is a class-loader, use a null protection-domain
    mv.visitLabel(notProtectionDomain);
    mv.visitFrame(
        F_FULL,
        3,
        new Object[] {INJECTED_GLUE_CLASS, OBJECT_CLASS, OBJECT_CLASS},
        6,
        new Object[] {unsafeClass, NULL, BYTE_ARRAY, INTEGER, INTEGER, OBJECT_CLASS});

    mv.visitTypeInsn(CHECKCAST, CLASSLOADER_CLASS);
    mv.visitInsn(ACONST_NULL);

    // finally invoke Unsafe.defineClass and return the defined class
    mv.visitLabel(invokeDefineClass);
    mv.visitFrame(
        F_FULL,
        3,
        new Object[] {INJECTED_GLUE_CLASS, OBJECT_CLASS, OBJECT_CLASS},
        7,
        new Object[] {
          unsafeClass, NULL, BYTE_ARRAY, INTEGER, INTEGER, CLASSLOADER_CLASS, PROTECTIONDOMAIN_CLASS
        });

    mv.visitMethodInsn(
        INVOKEVIRTUAL, unsafeClass, "defineClass", UNSAFE_DEFINECLASS_DESCRIPTOR, false);
    mv.visitInsn(ARETURN);
    mv.visitMaxs(7, 3);
    mv.visitEnd();

    // pad bytecode to even number of bytes, to make string encoding/decoding easier
    if ((unsafeNamespace.length() & 0x01) == 1) {
      cw.newConst(0);
    }

    cw.visitEnd();

    return cw.toByteArray();
  }

  public static void main(String[] args) throws IOException {
    if (args.length < 1 || !args[0].endsWith(".java")) {
      throw new IllegalArgumentException("Expected: java-file");
    }
    File file = new File(args[0]);
    String name = file.getName();
    List<String> lines = new ArrayList<>();
    classHeader(lines, name.substring(0, name.length() - 5));
    lines.add("  String ID = \"" + INJECTED_GLUE_CLASS.replace('/', '.') + "\";");
    lines.add("  String V8 =");
    packBytecode(lines, generateBytecode("sun/misc"));
    lines.add("  String V9 =");
    packBytecode(lines, generateBytecode("jdk/internal/misc"));
    lines.add("}");
    Files.write(file.toPath(), lines, StandardCharsets.UTF_8);
  }
}
